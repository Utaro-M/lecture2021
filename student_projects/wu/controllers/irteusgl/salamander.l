(load "webotslib.l")

(defconstant X 0)
(defconstant Y 1)
(defconstant Z 2)
(defconstant NUM_MOTORS 10)
(defconstant M_PI 3.141592)
(defconstant WATER_LEVEL 0.05)
(defconstant CONTROL_STEP 32)
(defconstant DESTINATION_X -0.6)

(setq spine_offset 0.0)
(setq ampl 1.0)
(setq phase 0.0)
(setq straight_time 0)
(setq turn_time 0)
(setq try_count 1)
(setq missing 0)
(setq found 10)
(setq state "origin")

(defconstant TURN_TIME_BOUND 180)
(defconstant STRAIGHT_TIME_BOUND 50)
(defconstant POOL_WIDTH 6)
(defconstant WALK 0)
(defconstant SWIM 1)
(setq locomotion WALK)
(setq min_motor_position (instantiate vector NUM_MOTORS))
(setq max_motor_position (instantiate vector NUM_MOTORS))

(defclass target :slots (len id_success))
(defmethod target
    (:init (&optional (length 0)) (setq len length) (setq id_success nil) self)
  (:incre_len () (setq len (+ len 1)))
  (:add_target (id)
	       (send self :incre_len)
	       (setq id_success (cons (cons id 0) id_success)))
  (:set_success (id)
		(dotimes (i len)
		  (if (eql id (car (nth i id_success)))
		      (progn (setf (cdr (nth i id_success)) 1)
			     (return))
		      nil)))
  (:print ()
	  (print len)
	  (print id_success))
  (:check_list (id)
	       (if (eql len 0)
		   (progn
		     (send self :add_target id)
		     (print "Add first target")
		     (return-from :check_list t))
		   (progn
		     (dolist (obj id_success)
		       (if (eql id (car obj))
			   (if (eql 0 (cdr obj))
			       (progn
				 (print "Found same id target")
				 (return-from :check_list t))
			       (progn
				 (print "Found succeeded target")
				 (return-from :check_list nil)))
			   nil))
		     (progn
		       (send self :add_target id)
		       (print "Add new target id")
		       (return-from :check_list t)))))
  (:clean_up ()
	     (setq len 0)
	     (setq id_success nil))
  (:print_success_id ()
		     (print "Current succeeded target ids:")
		     (dotimes (i len)
		       (if (eql 1 (cdr (nth i id_success)))
			   (format t "id: ~d ~%" (car (nth i id_success)))
			   nil))))

(setq target_list (instance target :init))
(setq current_target_id -1)

(defun clamp (value min max)
  (if (> min max) value
      (if (and (= min 0) (= max 0)) value
	  (if (< value min) min (if (> value max) max value)))))

(defun motion_control (dir bias dist)
  (if (< dist 0.03) (setq dist 0.03) nil)
  (case dir
    ((0)
     (progn
       (setq spine_offset (/ (* 0.3 bias) dist))
       (format t "Turning left, spine_offset: ~A ~%" spine_offset)))
    ((1)
     (progn
       (setq spine_offset (/ (* 0.3 bias) dist))
       (format t "Turning right, spine_offset: ~A ~%" spine_offset)))
    ((2)
     (progn
       (setq spine_offset 0)
       (print "Going straight")))))

(defun motion_dicision (bias dist)
  (format t "Found Object Position: ~A, ~A ~%" bias dist)
  (if (> bias 0.04)
      (motion_control 1 bias dist)
      (if (< bias -0.04)
	  (motion_control 0 bias dist)
	  (motion_control 2 bias dist))))

(defun searching ()
  (print "Searching")
  (if (and (< straight_time (* STRAIGHT_TIME_BOUND try_count))
	   (= turn_time 0))
      (progn (setq spine_offset 0)
	     (format t "Searching time ~d (go straight) ~%" try_count)
	     (setq straight_time (+ straight_time 1)))
      (if (and (= straight_time (* STRAIGHT_TIME_BOUND try_count))
	       (< turn_time TURN_TIME_BOUND))
	  (progn (setq spine_offset 0.3)
		 (format t "Searching time ~d (turn right) ~%" try_count)
		 (setq turn_time (+ turn_time 1)))
	  (progn (setq spine_offset 0)
		 (setq try_count (+ try_count 1))
		 (format t "New Searching, time ~d ~%" try_count)
		 (setq turn_time 0)
		 (setq straight_time 0)))))

(defun get_bearing_in_degrees (tag)
  (setq north (cout-cstruct (wb_compass_get_values tag) CompassPoint))
  (setq rad (atan (send north :get 'x) (send north :get 'z)))
  (setq bearing (* (/ (- rad 1.5708) M_PI) 180.0))
  (if (< bearing 0.0)
      (+ bearing 360.0)
      bearing))

(defun get_start (bearing gps_x)
  (if (> gps_x (- 0.8 POOL_WIDTH))
      (if (and (< bearing 120) (> bearing 60))
	  (progn
	    (setq spine_offset 0.0)
	    (print "Going_straight_origin")
	    (return-from get_start 0))
	  (progn
	    (setq spine_offset 0.3)
	    (print "Turning_right_origin")
	    (return-from get_start 0)))
      (progn
	(print "Reached origin")
	(return-from get_start 1))))

(defun detecting_garb (camera)
  (setq flag 0)
  (setq number_of_objects (wb_camera_recognition_get_number_of_objects camera))
  (format t "~%Recognized ~d objects. ~%" number_of_objects)
  (setq obj (instantiate wbcamerarecognitionobject))
  (setq robjs (instantiate vector number_of_objects))
  
  (if (eql 0 number_of_objects)
      (progn
	(print "Missing1 _ no object in the view")
	(setq missing (+ missing 1))
	(setq found 0)
	(if (> missing 40)
	    (searching)
	    nil))
      (tagbody
	 (dotimes (i number_of_objects)
	   (tagbody
	      (setf (elt robjs i)
		    (cout-cstruct (+ (wb_camera_recognition_get_objects camera)
				     (* (send wbcamerarecognitionobject :size) i))
				  wbcamerarecognitionobject))
	      (setq color (cout-float-vector (send (elt robjs i) :get+ 'colors) 3))

	      (if (and (eql 1.0 (elt color 0))
		       (eql 0.0 (elt color 1))
		       (eql 0.0 (elt color 2)))
		  (progn
		    (if (eql -1 current_target_id)
			(progn
			  (setq current_id (send (elt robjs i) :get 'id))
			  (setq temp_new (send target_list :check_list current_id))
			  (if (eql temp_new nil)
			      (go next)
			      (setq current_target_id current_id)))
			(if (not (eql current_target_id (send (elt robjs i) :get 'id)))
			    (go next)
			    nil))
		    (print "Currently detected targets:")
		    (send target_list :print)
		    (format t "CURRENT TARGET ID: ~d ~%" current_target_id)
		    (setq flag 1)
		    (setq missing 0)
		    (setq found (+ found 1))
		    (if (< found 2)
			(progn
			  (print "Found but keep on")
			  (go bottom))
			(progn
			  (setq straight_time 0)
			  (setq turn_time 0)
			  (setq try_count 1)
			  (motion_dicision (elt (send (elt robjs i) :get+ 'position) 0)
					   (- 0 (elt (send (elt robjs i) :get+ 'position) 2)))
			  (return-from detecting_garb 1)))))
	    next
	      ))
	 (if (eql flag 0)
	     (progn
	       (print "Missing2 _ Matching Error, not target object")
	       (setq missing (+ 1 missing))
	       (setq found 0)
	       (if (> missing 40)
		   (searching)
		   nil))
	     nil)
       bottom))
  (return-from detecting_garb 0))

(defun assess_motion (bearing gps_x)
  (if (and (< bearing 180)
	   (> bearing 0))
      (progn
	(print "Warning! Pushing backwards")
	(print "Going back origin")
	(return-from assess_motion 0))
      nil)
  (if (> gps_x DESTINATION_X)
      (progn
	(print "Mission Succeed")
	(print "Going back origin")
	(send target_list :set_success current_target_id)
	(setq current_target_id -1)
	(return-from assess_motion 0))
      nil)
  (return-from assess_motion 1))

(defun set_motion_pos (gps target_position)
  (setq FREQUENCY 1.4) ;; locomotion frequency [Hz]
  (setq WALK_AMPL 0.6) ;; radians
  (setq SWIM_AMPL 1.0) ;; radians
  (incf phase (- (* (/ CONTROL_STEP 1000.0) FREQUENCY 2.0 M_PI)))
  (if (< phase -280.0)
      (setq phase 0.0)
      nil)
  (setq elevation (elt (cout-float-vector (wb_gps_get_values gps) 3) Y))
  (cond
    ((and (= locomotion SWIM) (> elevation (- WATER_LEVEL 0.003)))
     (setq locomotion WALK)
     (setq phase (elt target_position 6)))
    ((and (= locomotion WALK) (< elevation (- WATER_LEVEL 0.015)))
     (setq locomotion SWIM)
     (setq backwards_position (- phase (mod phase (* 2.0 M_PI)) (/ M_PI 2)))
     (dotimes (i 6) (setf (elt target_position i) backwards_position))))
  (cond
    ((= locomotion WALK) (setq A (vector -0.7 1 1 0 -1 -1))
     (dotimes (i 6)
       (setf (elt target_position i)
	     (+ (* WALK_AMPL ampl (elt A i) (sin phase)) spine_offset)))
     (setf (elt target_position 6) phase)
     (setf (elt target_position 7) (+ phase M_PI))
     (setf (elt target_position 8) (+ phase M_PI))
     (setf (elt target_position 9) phase))
    (t ;; swim
     (dotimes (i 6)
       (setf (elt target_position i)
	     (+ (* SWIM_AMPL ampl
		   (sin (+ phase (* i 2 (/ M_PI 6)))) (/ (+ i 5) 10.0))
		spine_offset))))))

(defun salamander-main ()
  (setq motor (instantiate vector NUM_MOTORS))
  (setq target_position (instantiate vector NUM_MOTORS))
  (wb_robot_init)
  (setq TIME_STEP 64)
  (setq camera (wb_robot_get_device "camera"))
  (wb_camera_enable camera TIME_STEP)
  (wb_camera_recognition_enable camera TIME_STEP)
  (setq compass (wb_robot_get_device "compass"))
  (wb_compass_enable compass TIME_STEP)
  (setq MOTOR_NAMES (vector "motor_1" "motor_2"
			    "motor_3" "motor_4" "motor_5" "motor_6" "motor_leg_1"
			    "motor_leg_2" "motor_leg_3" "motor_leg_4"))
  (dotimes (i num_motors)
    (setf (elt motor i) (wb_robot_get_device (elt
					      MOTOR_NAMES i)))
    (setf (elt min_motor_position i)
	  (wb_motor_get_min_position (elt motor i)))
    (setf (elt max_motor_position i)
	  (wb_motor_get_max_position (elt motor i))))
  (setq gps (wb_robot_get_device "gps"))
  (wb_gps_enable gps CONTROL_STEP)

  (setq detected 0)
  (setq origin 0)
  (while (not (= (wb_robot_step CONTROL_STEP) -1))
    (setq bearing (get_bearing_in_degrees compass))
    (print "bearing: ")
    (print bearing)
    (setq gps_x (elt (cout-float-vector (wb_gps_get_values gps) 3) X))

    (cond ((equal state "origin")
           (print "Go origin")
	   (setq origin (get_start bearing gps_x))
           (if (= origin 1)
               (setq state "detect")
               nil))
	  ((equal state "detect")
	   (setq detected (detecting_garb camera))
	   (if (= detected 1)
	       (setq state "assess")))
	  ((equal state "assess")
	   (setq origin (assess_motion bearing gps_x))
	   (if (= origin 1)
	       (setq state "detect")
	       (setq state "origin"))))

    (if t
	(set_motion_pos gps target_position)
	nil)
    (dotimes (i num_motors)
      (setf (elt target_position i) (clamp (elt target_position i)
					   (elt min_motor_position i) 
                                           (elt max_motor_position i)))
      (wb_motor_set_position (elt motor i) (elt target_position i)))
    (send target_list :print_success_id))
  (wb_robot_cleanup))


(salamander-main)
