;;(load "~/prog/rcb4eus/makabe-common-function.l")
(require :kxrl2makabeorig)

(setq *start-angle-vector* nil)
(setq *ref-angle-vector* nil)
(setq *d-angle-vector* nil)
(setq *count* nil)
(setq *ref-time* nil)
(setq *step-num* nil)
(setq *active* nil)
(setq *prev-active* nil)
(setq *contact-check* nil)
(setq *contact-list* '(nil nil nil nil))
;;t:contact l/r link, nil:else (gripper2-r, wrist-w, ankle-r, knee-w)
(setq contact-link-name '(("gripper2-r" 0) ("wrist-w" 1) ("ankle-r" 2) ("knee-w" 3)))
(defparameter *contact-link-name* '((:gripper2-r . 0) (:wrist-w . 1) (:ankle-r . 2) (:knee-w . 3)))
(setq *imu-vec* nil)
(setq *fl* nil)
(setq *squat-rpy* (float-vector 0.278 0.0 0.0))
(setq *car-rpy* (float-vector 0.001 0.0 0.0))
(setq *tmp-result* nil);;0:fail, 1:unstable-succeed 2:succeed
(setq *result* nil);;0:fail, 1:unstable-succeed 2:succeed
(setq *ref-state* nil);;0:squat4, 1:car
(setq *squat-state* 0)
(setq *car-state* 1)

(defun test-motion()
  (format t"motion-sample ~%")
  )

(defun da()
  (send *irtviewer* :draw-objects)
  )

(defun make-makabe ()
  (setq *robot* (kxrl2makabeorig))
  (objects (list *robot*))
  )

(defmethod kxrl2makabeorig-robot
  (:stand-pose
   ()
   (let ((c (make-cascoords :pos (send self :worldpos))))
     (send self :neutral)
     (send self :larm-shoulder-r :joint-angle 10)
     (send self :rarm-shoulder-r :joint-angle -10)
     (send self :larm-gripper-r :joint-angle -23)
     (send self :rarm-gripper-r :joint-angle -23)
     (send self :larm-gripper2-r :joint-angle -23)
     (send self :rarm-gripper2-r :joint-angle -23)     
     ;;
     ;; (send self :hand-close)
     ;;
     ;;(send self :newcoords c)
     ;; (send self :move-on-ground)
     ;; (send self :draw-collision)
     )
   )
  (:car-pose
   ()
   (let ((c (make-cascoords :pos (send self :worldpos))))
     (send self :larm-gripper-r :joint-angle -23)
     (send self :rarm-gripper-r :joint-angle -23)
     (send self :larm-gripper2-r :joint-angle -23)
     (send self :rarm-gripper2-r :joint-angle -23)
     (send self :legs :crotch-p :joint-angle -90)
     (send self :torso-chest-p :joint-angle -90)
     (send self :legs :knee-p :joint-angle 135)
     (send self :legs :ankle-p :joint-angle -45)
     (send self :larm-shoulder-y :joint-angle -90)
     (send self :rarm-shoulder-y :joint-angle 90)
     (send self :larm-elbow-y :joint-angle -90)
     (send self :rarm-elbow-y :joint-angle 90)
     (send self :larm-wrist-y :joint-angle 90)
     (send self :rarm-wrist-y :joint-angle -90)
     (send self :larm-wrist-r :joint-angle -90)
     (send self :rarm-wrist-r :joint-angle 90)
     ;; (send c :rotate pi/2 :y :world)
     ;; (send c :locate #f(-150 0 50) :world)
     ;; (send self :newcoords c)
     ;; (send self :move-on-ground)
     ;; (send self :draw-collision)
     )
   )
  )

(defun init-makabe (&key (crds (make-coords)) (draw t))
  (send *robot* :init-pose)
  (send *robot* :fix-leg-to-coords crds)
  (send *robot* :rarm-shoulder-r :joint-angle (h2h-to-angle 300))
  (send *robot* :larm-shoulder-r :joint-angle (h2h-to-angle -300))
  (send *robot* :rarm-gripper-r :joint-angle -23)
  (send *robot* :rarm-gripper2-r :joint-angle -23)
  (send *robot* :larm-gripper-r :joint-angle -23)
  (send *robot* :larm-gripper2-r :joint-angle -23) 
  (send *robot* :rleg-knee-w :joint-angle (h2h-to-angle 7 :sign t))
  (send *robot* :lleg-knee-w :joint-angle (h2h-to-angle 7 :sign nil))
  (send *robot* :fix-leg-to-coords crds)
  (if draw
      (send *irtviewer* :draw-objects)
    )
  (send *robot* :angle-vector)
  )

(defun squat-1 (&key (crds (make-coords)) (draw t));;50frame
  (init-makabe :draw nil)
  (send *robot* :rleg-crotch-p :joint-angle (h2h-to-angle 1000 :waist t :sign t))
  (send *robot* :rleg-knee-p :joint-angle (h2h-to-angle -1000))
  (send *robot* :rleg-ankle-p :joint-angle (h2h-to-angle 500))
  (send *robot* :lleg-crotch-p :joint-angle (h2h-to-angle -1000 :waist t :sign nil))
  (send *robot* :lleg-knee-p :joint-angle (h2h-to-angle -1000))
  (send *robot* :lleg-ankle-p :joint-angle (h2h-to-angle 500))
  (send *robot* :fix-leg-to-coords crds)
  (if draw
      (send *irtviewer* :draw-objects)
    )
  (send *robot* :angle-vector)
  )

(defun squat-1.9 (&key (crds (make-coords)) (draw t));;50frame
  (squat-2 :draw nil)
  (send *robot* :rarm-elbow-y :joint-angle 0)
  (send *robot* :larm-elbow-y :joint-angle 0)
  (send *robot* :fix-leg-to-coords crds)
  (if draw
      (send *irtviewer* :draw-objects)
    )
  (send *robot* :angle-vector)
  )

(defun squat-2 (&key (crds (make-coords)) (draw t));;50frame
  (squat-1 :draw nil)
  (send *robot* :rleg-crotch-p :joint-angle (h2h-to-angle 4000 :waist t :sign t))
  (send *robot* :rleg-knee-p :joint-angle (h2h-to-angle -4000))
  (send *robot* :rleg-ankle-p :joint-angle (h2h-to-angle 1325))
  (send *robot* :rarm-elbow-y :joint-angle (h2h-to-angle 2666 :sign t))
  (send *robot* :lleg-crotch-p :joint-angle (h2h-to-angle -4000 :waist t :sign nil))
  (send *robot* :lleg-knee-p :joint-angle (h2h-to-angle -4000))
  (send *robot* :lleg-ankle-p :joint-angle (h2h-to-angle 1325))
  (send *robot* :larm-elbow-y :joint-angle (h2h-to-angle 2666 :sign nil))
  (send *robot* :fix-leg-to-coords crds)
  (if draw
      (send *irtviewer* :draw-objects)
    )
  (send *robot* :angle-vector)
  )

(defun squat-2.6 (&key (crds (make-coords)) (draw t));;50frame
  (squat-3 :draw nil)
  (setq *real-p* 0.518)
  (send *robot* :torso-chest-p :joint-angle 45)
  (send *robot* :rarm-shoulder-y :joint-angle 55)
  (send *robot* :larm-shoulder-y :joint-angle -55)
  (send *robot* :rleg-crotch-p :joint-angle -55)
  (send *robot* :lleg-crotch-p :joint-angle -55)
  (send *robot* :rleg-ankle-p :joint-angle -50)
  (send *robot* :lleg-ankle-p :joint-angle -50)
  (send *robot* :fix-leg-to-coords crds)
  (if draw
      (send *irtviewer* :draw-objects)
    )
  (send *robot* :angle-vector)
  )

(defun squat-3 (&key (crds (make-coords)) (draw t));;50frame
  (squat-2 :draw nil)
  (setq *real-p* 0.48)
  (send *robot* :torso-chest-p :joint-angle (h2h-to-angle 300 :waist t))
  (send *robot* :rarm-shoulder-y :joint-angle (h2h-to-angle 2000 :sign t))
  (send *robot* :larm-shoulder-y :joint-angle (h2h-to-angle -2000 :sign t))
  (send *robot* :rarm-shoulder-r :joint-angle (h2h-to-angle 1100))
  (send *robot* :larm-shoulder-r :joint-angle (h2h-to-angle -1100))
  (send *robot* :rarm-gripper-r :joint-angle 0)
  (send *robot* :larm-gripper-r :joint-angle 0)
  (send *robot* :rarm-gripper2-r :joint-angle 0)
  (send *robot* :larm-gripper2-r :joint-angle 0)
  (send *robot* :fix-leg-to-coords crds)
  (if draw
      (send *irtviewer* :draw-objects)
    )
  (send *robot* :angle-vector)
  )

(defun squat-4 (&key (crds (make-coords)) (draw t));;50frame
  (squat-3 :draw nil)
  (setq *real-p* 0.6)
  (send *robot* :torso-chest-p :joint-angle (h2h-to-angle 750 :waist t))
  (send *robot* :rarm-shoulder-y :joint-angle (h2h-to-angle 2666 :sign t))
  (send *robot* :larm-shoulder-y :joint-angle (h2h-to-angle -2666 :sign t))
  (send *robot* :rarm-shoulder-r :joint-angle (h2h-to-angle 1300))
  (send *robot* :larm-shoulder-r :joint-angle (h2h-to-angle -1300))
  (send *robot* :rarm-gripper-r :joint-angle -20)
  (send *robot* :larm-gripper-r :joint-angle -20)
  ;;(send *robot* :rarm-gripper2-r :joint-angle -20)
  ;;(send *robot* :larm-gripper2-r :joint-angle -20)
  (send *robot* :rarm-gripper2-r :joint-angle 0)
  (send *robot* :larm-gripper2-r :joint-angle 0)
  (send *robot* :fix-leg-to-coords crds)
  (if draw
      (send *irtviewer* :draw-objects)
    )
  (send *robot* :angle-vector)
  )

(defun squat-5 (&key (crds (make-coords)) (draw t));;50frame
  (squat-4 :draw nil)
  (setq *real-p* 0.03)
  (send *robot* :torso-chest-p :joint-angle (h2h-to-angle -4000 :waist t))
  (send *robot* :rarm-shoulder-r :joint-angle (h2h-to-angle 500))
  (send *robot* :larm-shoulder-r :joint-angle (h2h-to-angle -500))
  (send *robot* :rarm-wrist-y :joint-angle (h2h-to-angle 2666))
  (send *robot* :larm-wrist-y :joint-angle (h2h-to-angle -2666))
  (send *robot* :rarm-wrist-r :joint-angle (h2h-to-angle 2000 :sign t))
  (send *robot* :larm-wrist-r :joint-angle (h2h-to-angle -2000 :sign t))
  (send *robot* :fix-leg-to-coords crds)
  (if draw
      (send *irtviewer* :draw-objects)
    )
  (send *robot* :angle-vector)
  )

(defun init-car (&key (crds (make-coords)) (draw t));;50frame
  (squat-5 :draw nil)
  (setq *real-p* 0.03)
  (send *robot* :rarm-wrist-r :joint-angle (h2h-to-angle 2666 :sign t))
  (send *robot* :larm-wrist-r :joint-angle (h2h-to-angle -2666 :sign t))
  (send *robot* :rarm-elbow-p :joint-angle (h2h-to-angle 500))
  (send *robot* :larm-elbow-p :joint-angle (h2h-to-angle 500))
  ;; (send *robot* :rarm-gripper2-r :joint-angle -20)
  ;; (send *robot* :larm-gripper2-r :joint-angle -20)
  (send *robot* :fix-leg-to-coords crds)
  (if draw
      (send *irtviewer* :draw-objects)
    )
  (send *robot* :angle-vector)
  )

(defun h2h-to-angle (val &key (sign nil) (waist nil))
  (let (angle)
    (cond (waist
           (cond (sign
                  (setq angle (- (/ (* val 135.0) 6000)))
                  )
                 (t
                  (setq angle (/ (* val 135.0) 6000))
                  )
                 )
           )
          (t
           (cond (sign
                  (setq angle (/ (* val 135.0) 4000))
                  )
                 (t
                  (setq angle (- (/ (* val 135.0) 4000)))
                  )
                 )
           )
          )
    )
  )

(defun angle-to-h2h (val &key (sign nil) (waist nil))
  (let (h2h)
    (cond (waist
           (cond (sign
                  (setq h2h (- (/ (* val 6000.0) 135)))
                  )
                 (t
                  (setq h2h (/ (* val 6000.0) 135))
                  )
                 )
           )
          (t
           (cond (sign
                  (setq h2h (- (/ (* val 4000.0) 135)))
                  )
                 (t
                  (setq h2h (/ (* val 4000.0) 135))
                  )
                 )
           )
          )
    (setq h2h (+ h2h 7500))
    )
  )

(defun car2humanoid-simple (&key (time 1000) (run nil) (crds (make-coords)))
  (let ((*frame* 10));;1frame = 10[ms]
    (init-car)
    (send *irtviewer* :draw-objects)
    (when run
      (send *ri* :angle-vector (send *robot* :angle-vector) (/ time *frame*))
      )
    (unix::usleep (* time 1000))

    (format t "press key : start transform~%")
    (do-until-key)

    (squat-4)
    (when run
      (send *ri* :angle-vector (send *robot* :angle-vector) (/ time *frame*))
      )
    (send *irtviewer* :draw-objects)
    (unix::usleep (* time 1000))
    
    (squat-3)
    (send *irtviewer* :draw-objects)
    (when run
      (send *ri* :angle-vector (send *robot* :angle-vector) (/ time *frame*))
      )
    (unix::usleep (* time 1000))
    
    (squat-2.6)
    (send *irtviewer* :draw-objects)
    (when run
      (send *ri* :angle-vector (send *robot* :angle-vector) (/ time *frame*))
      )
    (unix::usleep (* time 1000))
    
    (squat-1.9)
    (send *irtviewer* :draw-objects)
    (when run
      (send *ri* :angle-vector (send *robot* :angle-vector) (/ time *frame*))
      )
    (unix::usleep (* time 1000))
    
    (format t "finish transform~%")
    )
  )

(defun humanoid2car-simple (&key (time 1000) (run nil) (crds (make-coords)))
  (let ((*frame* 10));;1frame = 10[ms]
    (send *robot* :stand-pose)
    (send *robot* :fix-leg-to-coords crds)
    (send *irtviewer* :draw-objects)
    (when run
      (send *ri* :angle-vector (send *robot* :angle-vector) (/ time *frame*))
      )
    (unix::usleep (* time 1000))

    (format t "press key : start transform~%")
    (do-until-key)

    (squat-1.9)
    (send *irtviewer* :draw-objects)
    (when run
      (send *ri* :angle-vector (send *robot* :angle-vector) (/ time *frame*))
      )
    (unix::usleep (* time 1000))

    (squat-2.6)
    (when run
      (send *ri* :angle-vector (send *robot* :angle-vector) (/ time *frame*))
      )
    (send *irtviewer* :draw-objects)
    (unix::usleep (* time 1000))
    
    (squat-3)
    (send *irtviewer* :draw-objects)
    (when run
      (send *ri* :angle-vector (send *robot* :angle-vector) (/ time *frame*))
      )
    (unix::usleep (* time 1000))
    
    (squat-4)
    (send *irtviewer* :draw-objects)
    (when run
      (send *ri* :angle-vector (send *robot* :angle-vector) (/ time *frame*))
      )
    (unix::usleep (* time 1000))
    
    (init-car)
    (send *irtviewer* :draw-objects)
    (when run
      (send *ri* :angle-vector (send *robot* :angle-vector) (/ time *frame*))
      )
    (unix::usleep (* time 1000))
    
    (format t "finish transform~%")
    )
  )

(defun send-init-pose ()
  (squat-1.9)
  (send-webots)
  )

(defun send-start-pose ()
  (squat-4)
  (send-webots)
  )

(defun send-end-pose ()
  (init-car)
  (send-webots)
  )

(defun set-refpose-time (&key (start *squat-state*) (ref *squat-state*) (time 1000) (contact t))
  (let ()
    (setq *active* t)
    (setq *contact-check* contact)
    (setq *tmp-result* 2)
    (print "start-angle-vector")
    (setq *start-angle-vector* (state2vector :state start))
    ;;(setq *start-angle-vector* (squat-4))
    ;;(setq *start-angle-vector* (init-car))
    (print *start-angle-vector*)
    (print "ref-angle-vector")
    (setq *ref-angle-vector* (state2vector :state ref))
    ;;(setq *ref-angle-vector* (init-car))
    ;;(setq *ref-angle-vector* (squat-4))
    (print *ref-angle-vector*)
    (setq *count* 0)
    (setq *ref-time* time)
    (setq *ref-state* ref)
    (setq *step-num* (+ 1 (/ *ref-time* time_step)));;time_step 32ms
    (format t "step-num:~A~%" *step-num*)
    (setq *d-angle-vector* (scale (/ 1.0 *step-num*) (v- *ref-angle-vector* *start-angle-vector*)));;dtheta/dt, dt = time_step
    (format t "~A~%" contact-link-name)
    (format t "*imu-vec*:~A~%" *imu-vec*)
    )
  )

(defun state2vector (&key (state *squat-state*))
  (cond ((= state *squat-state*)
	 (squat-4)
	 )
	((= state *car-state*)
	 (init-car)
	 )
	(t
	 (squat-4)
	 )
	)
  ;;send *robot* :angle-vector
  )

(defun update-imu nil
  (setq *imu-vec* (cout-float-vector (wb_inertial_unit_get_roll_pitch_yaw *imu*) 3))
  (format t "*imu-vec*:~A~%" *imu-vec*)
  )

(format t "(set-refpose-time :start *squat-state* :ref *car-state* :time 500)~%")
(format t "(set-refpose-time :start *car-state* :ref *squat-state* :time 500)~%")

(defun transform_step (&key (debug nil) (run t))
  (let (i-v)
    (when *contact-check*
      (print-contact-link-eus)
      )
    (setq *prev-active* *active*)
    (when *active*
      (when debug
	(format t "*count*:~A~%" *count*)
	)
      (cond ((< *count* *step-num*)
	     (setq *count* (+ *count* 1))
	     (setq i-v (v+ *start-angle-vector* (scale *count* *d-angle-vector*)))
	     )
	    (t
	     (setq *active* nil)
	     (setq *contact-check* nil)
	     (setq i-v *ref-angle-vector*)
	     (format t "*imu-vec*:~A~%" *imu-vec*)
	     )
	    )
      (when debug
	(print "======")
	(print i-v)
	)
      (when *contact-check*
	(format t "*count*:~A~%" *count*)
	)
      (when run
	(send *robot* :angle-vector i-v)
	(send-webots)
	(when (and *prev-active* (not *active*))
	  (unix:usleep (* 1000 2000))
	  (setq *result* 0)
	  (when (check-posture :debug t)
	    (setq *result* *tmp-result*)
	    )
	  (print *result*)
	  (cond ((= *result* 0)
		 (format t "fail~%")
		 )
		((= *result* 1)
		 (format t "unstable succeed~%")
		 )
		((= *result* 2)
		 (format t "succeed~%")
		 )
		)
	  (when *test-active*
	    (if *test-sign*
		(setq *test-count* (+ 1 *test-count*))
	      )
	    (setq *test-prev-active* *test-active*)
	    (when (= *test-count* *test-num*)
	      (setq *test-active* nil)
	      )
	    (cond ((and *test-prev-active* (not *test-active*))
		   (format t "finish~%")
		   (reverse *result-vec*)
		   (format t "best-time:~A~%" *best-time*)
		   (format t "result-vector:~A~%" *result-vec*)
		   )
		  (t)
		  )
	    )
	  )
	)
      )
    )
  )

(defun toggle-contact nil
  (setq *contact-check* (not *contact-check*))
  )

(defun print-contact-link-webots (&key (def "KXRL2MAKABE"))
  (let* ((id (wb_supervisor_node_get_from_def def))
	 (cp-num (wb_supervisor_node_get_number_of_contact_points id))
	 (count 0) tmp-id)
    (format t "DEF:~A~%" def)
    (format t "contact-point-num:~A~%" cp-num)
    (while (< count cp-num)
      (setq tmp-id (wb_supervisor_node_get_contact_point_node id count))
      (format t "index:~A node:~A~%" count tmp-id)
      (format t "node name:~A~%" (wb_supervisor_field_get_sf_string(wb_supervisor_node_get_field tmp-id "name")))
      (setq count (+ 1 count)))
      )
    )
)

(defun make-floor nil
  (setq *fl* (make-cube 750 750 1))
  (send *fl* :translate #f(0 0 -0.5))
  (send *robot* :fix-leg-to-coords (make-coords))
  (objects (list *robot* *fl*))
  )

(defun print-contact-link-eus (&key (min-th 5) (init-h 300) (debug nil))
  (let* ((crds (make-coords))
	 (min-h init-h)
	 (l-name)
	 (tmp-list '(nil nil nil nil)))
    (if (not *fl*) (make-floor))
    (setq *imu-vec* (cout-float-vector (wb_inertial_unit_get_roll_pitch_yaw *imu*) 3))
    (update-robot-crds :rpy-vec *imu-vec* :h init-h :debug debug)
    (dolist (l (find-descendants *robot*))
      (setq tmp (car (bt-collision-distance l *fl*)))
      (when (< tmp min-h)
	(setq min-h tmp)
	)
      )
    (update-robot-crds :rpy-vec *imu-vec* :h (- init-h min-h) :debug debug)
    (when debug
      (format t "minimum distance threshold:~A[mm]~%" min-th)
      )
    (setf (elt tmp-list 0) nil)
    (setf (elt tmp-list 1) nil)
    (setf (elt tmp-list 2) nil)
    (setf (elt tmp-list 3) nil)
    ;;(print *contact-list*)
    (dolist (l (find-descendants *robot*))
      (setq tmp (car (bt-collision-distance l *fl*)))
      (setq l-name (send l :name))
      (when (< tmp min-th)	
	(dolist (a contact-link-name)
	  (cond ((substringp (elt a 0) l-name)
		 ;;(print (elt a 0))
		 (setf (elt tmp-list (elt a 1)) t)
		 )
		)
	  )
	)
      (when debug
	(print (list l-name tmp min-h))
	)
      )
    (setf *contact-list* tmp-list)
    (format t "~A~%" *contact-list*)
    (cond ((and (or (elt *contact-list* 0) (elt *contact-list* 1)) (or (elt *contact-list* 2) (elt *contact-list* 3)))
	   (print "stable")
	   )
	  (t
	   (print "unstable")
	   (setq *tmp-result* 1)
	   )
	  )
    )
  )

(defun update-robot-crds (&key (rpy-vec (float-vector 0 0 0)) (h 0) (debug nil))
  (let* ((crds (make-coords)))
    (when debug
      (print crds)
      )
    (send crds :translate (float-vector 0 0 h))
    (send crds :rotate (elt rpy-vec 1) (float-vector 1 0 0))
    (send crds :rotate (elt rpy-vec 0) (float-vector 0 1 0))
    (send *robot* :move-coords crds (send (elt (send *robot* :links) 33) :worldcoords))
    )
  )

(defun find-descendants (root &optional (target-class bodyset-link))
  (labels ((all-descendants (p)
			    (if p
				(append (list p)
					(mapcan #'all-descendants (send p :descendants))))))
	  (remove-if-not #'(lambda (x) (derivedp x target-class))
			 (all-descendants root))
	  )
  )

(defun check-posture (&key (th 0.15) (debug nil))
  (let (diff-v)
    (update-imu)
    (cond ((= *ref-state* *car-state*)
	   (setq diff-v (v- *imu-vec* *car-rpy*))
	   (setf (elt diff-v 2) 0)
	   )
	  ((= *ref-state* *squat-state*)
	   (setq diff-v (v- *imu-vec* *squat-rpy*))
	   (setf (elt diff-v 2) 0)
	   )
	  (t
	   (setq diff-v (v- *imu-vec* *squat-rpy*))
	   (setf (elt diff-v 2) 0)
	   )
	  )
    (when debug
      (print (norm diff-v))
      )
    (< (norm diff-v) th)
    )
  )


(setq *min-time* nil)
(setq *max-time* nil)
(setq *step-time* nil)
(setq *best-time* nil)

(setq *test-count* 0)
(setq *test-num* nil)
(setq *test-times* nil)
(setq *test-active* nil)
(setq *test-prev-active* nil)
(setq *test-sign* nil)

(setq *best-result* nil)
(setq *result-vec* '())
(setq *b-time* nil)

(defun search-min-time (&key (max 3000) (min 0) (step 200) (b-time 500))
  (let ()
    (setq *min-time* min)
    (setq *max-time* max)
    (setq *step-time* step)
    (setq *best-time* max)
    (setq *test-count* 0)
    (setq *test-num* (+ 1 (/ (- max min) step)))
    (setq *test-time* max)
    (setq *best-result* 0)
    (setf *result-vec* '())
    (setq *b-time* b-time)
    (setq *test-active* t)
    (setq *test-sign* t)
    )  
  )

(format t "(search-min-time :max 1100 :min 500 :step 200 :b-time 500)~%")

(defun setpose_step nil
  (let ((tmp-time))
    (when *test-active*
      (when (not *active*)
	(cond (*test-sign*
	       (format t "*test-count*:~A~%" *test-count*)
	       (setq *test-time* (- *max-time* (* *test-count* *step-time*)))
	       (format t "*test-time*:~A~%" *test-time*)
	       (set-refpose-time :start *squat-state* :ref *car-state* :time *test-time* :contact t)
	       )
	      (t
	       (push *result* *result-vec*)
	       (when (or (= *result* *best-result*) (> *result* *best-result*))
		 (setq *best-result* *result*)
		 (setq *best-time* *test-time*)
		 )
	       (set-refpose-time :start *car-state* :ref *squat-state* :time *b-time* :contact nil)
	       )
	      )
	(setq *test-sign* (not *test-sign*))
	)
      )
    )
  )
